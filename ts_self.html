<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æœ¬åœ°æ–‡æ¡£å€’æ’ç´¢å¼•ç³»ç»Ÿ</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; max-width: 900px; margin: 2rem auto; padding: 0 1rem; background: #f8f9fa; color: #333; }
        
        /* é¡¶éƒ¨æ§åˆ¶åŒº */
        .control-panel { background: white; padding: 25px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); margin-bottom: 25px; }
        h1 { margin-top: 0; font-size: 24px; display: flex; align-items: center; gap: 10px; }
        
        /* æ–‡ä»¶ä¸Šä¼ æŒ‰é’®ç¾åŒ– */
        .file-upload-wrapper { margin: 20px 0; padding: 20px; border: 2px dashed #cbd5e0; border-radius: 8px; text-align: center; background: #f7fafc; transition: all 0.3s; }
        .file-upload-wrapper:hover { border-color: #4299e1; background: #ebf8ff; }
        .file-upload-label { cursor: pointer; color: #4299e1; font-weight: bold; font-size: 16px; }
        #folderInput { display: none; }
        .stats { font-size: 14px; color: #718096; margin-top: 10px; }

        /* æœç´¢æ¡† */
        .search-box { width: 100%; padding: 15px; font-size: 18px; border: 2px solid #e2e8f0; border-radius: 8px; box-sizing: border-box; margin-top: 15px; transition: border-color 0.2s; }
        .search-box:focus { border-color: #4299e1; outline: none; box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.2); }
        .search-box:disabled { background-color: #edf2f7; cursor: not-allowed; }

        /* ç»“æœåˆ—è¡¨ */
        .result-item { background: white; padding: 15px 20px; border-radius: 8px; margin-bottom: 12px; border-left: 4px solid transparent; box-shadow: 0 2px 4px rgba(0,0,0,0.02); cursor: pointer; transition: transform 0.2s; }
        .result-item:hover { transform: translateX(5px); border-left-color: #4299e1; box-shadow: 0 4px 6px rgba(0,0,0,0.05); }
        .result-title { font-size: 16px; font-weight: 600; color: #2d3748; margin-bottom: 6px; display: flex; justify-content: space-between; }
        .result-path { font-size: 12px; color: #a0aec0; font-family: monospace; margin-bottom: 8px; }
        .result-snippet { font-size: 14px; color: #4a5568; line-height: 1.6; background: #fffaf0; padding: 8px; border-radius: 4px; }
        
        /* é«˜äº®æ ·å¼ */
        .highlight { background-color: #fefcbf; color: #744210; font-weight: bold; padding: 0 2px; border-radius: 2px; }
        .score-badge { background: #edf2f7; padding: 2px 8px; border-radius: 12px; font-size: 12px; color: #4a5568; }

        /* åŠ è½½åŠ¨ç”» */
        .loading { display: none; color: #4299e1; font-weight: bold; margin-top: 10px; }
    </style>
</head>
<body>

    <div class="control-panel">
        <h1>ğŸ“‚ æœ¬åœ°æ–‡æ¡£æ£€ç´¢å¼•æ“ <span style="font-size:12px; background:#48bb78; color:white; padding:2px 6px; border-radius:4px;">Inverted Index Powered</span></h1>
        
        <div class="file-upload-wrapper" id="dropZone">
            <label for="folderInput" class="file-upload-label">
                ğŸ“ ç‚¹å‡»é€‰æ‹©æ–‡ä»¶å¤¹ (æˆ–å°†æ–‡ä»¶å¤¹æ‹–å…¥æ­¤å¤„)
            </label>
            <p style="font-size:12px; color:#718096; margin: 5px 0;">ä»…æ”¯æŒè¯»å– .txt, .md, .json, .js, .html ç­‰æ–‡æœ¬æ–‡ä»¶</p>
            <input type="file" id="folderInput" webkitdirectory multiple>
            <div class="loading" id="loadingMsg">æ­£åœ¨å»ºç«‹å€’æ’ç´¢å¼•ï¼Œè¯·ç¨å€™...</div>
            <div class="stats" id="statsMsg">ç­‰å¾…å¯¼å…¥æ•°æ®...</div>
        </div>

        <input type="text" id="searchInput" class="search-box" placeholder="è¯·å…ˆå¯¼å…¥æ–‡ä»¶å¤¹..." disabled>
    </div>

    <div id="results"></div>

    <script>
        // ============================================================
        // æ ¸å¿ƒç®—æ³•ï¼šå€’æ’ç´¢å¼• (Inverted Index) + æ¨¡ç³ŠåŒ¹é…
        // ============================================================
       const STOP_WORDS = new Set([
        "çš„", "äº†", "å’Œ", "æ˜¯", "åœ¨", "æˆ‘", "æœ‰", "å°±", "ä¸", "äºº", "éƒ½", "ä¸€", "ä¸€ä¸ª", "ä¸Š", "ä¹Ÿ", "å¾ˆ", "åˆ°", "è¯´", "è¦", "å»", "ä½ ", "ä¼š", "ç€", "æ²¡æœ‰", "çœ‹", "å¥½", "è‡ªå·±", "è¿™",
        "the", "is", "at", "which", "on", "in", "a", "an", "and", "or", "of", "to", "it", "that", "for", "with", "as", "by"
    ]);

    class AdvancedSearchEngine {
        constructor() {
            this.index = new Map(); // å€’æ’è¡¨: { "å•è¯": { docId: TFå€¼, ... } }
            this.documents = new Map(); // æ­£å‘è¡¨
            this.docCount = 0; // N (æ–‡æ¡£æ€»æ•°)
        }

        tokenize(text) {
            // 1. åˆ†è¯ (ä¸­æ–‡+è‹±æ–‡å•è¯)
            let tokens = text.toLowerCase().match(/[\u4e00-\u9fa5]|[a-zA-Z0-9]+/g) || [];
            // 2. åœç”¨è¯è¿‡æ»¤ (Stopwords Removal)
            return tokens.filter(t => !STOP_WORDS.has(t));
        }

        addDocument(fileObj, content) {
            const docId = ++this.docCount;
            
            // ç®€å•æ¨¡æ‹Ÿï¼šç»™äºˆæ ‡é¢˜æ›´é«˜çš„ TF æƒé‡ (Field Boosting)
            // æˆ‘ä»¬æŠŠæ ‡é¢˜é‡Œçš„è¯é‡å¤åŠ å…¥ 5 æ¬¡ï¼Œå˜ç›¸æé«˜å®ƒçš„ TF
            const titleContent = (fileObj.name + " ").repeat(5);
            const fullText = titleContent + content;
            
            const tokens = this.tokenize(fullText);
            const tokenCounts = {}; // è®¡ç®—å½“å‰æ–‡æ¡£çš„ TF

            tokens.forEach(token => {
                tokenCounts[token] = (tokenCounts[token] || 0) + 1;
            });

            // å­˜å…¥æ­£å‘è¡¨
            this.documents.set(docId, {
                id: docId,
                name: fileObj.name,
                path: fileObj.webkitRelativePath || fileObj.name,
                content: content,
                fileRef: fileObj,
                length: tokens.length // è®°å½•æ–‡æ¡£é•¿åº¦ (ä¸ºæœªæ¥åš BM25 é¢„ç•™)
            });

            // å­˜å…¥å€’æ’è¡¨
            for (const [token, tf] of Object.entries(tokenCounts)) {
                if (!this.index.has(token)) {
                    this.index.set(token, new Map()); // Map<docId, TF>
                }
                this.index.get(token).set(docId, tf);
            }
        }

        search(query) {
            if (!query.trim()) return [];
            
            const queryTokens = this.tokenize(query);
            const docScores = new Map(); // { docId: FinalScore }

            // éå†æŸ¥è¯¢è¯
            queryTokens.forEach(qToken => {
                // -----------------------------------------
                // ç­–ç•¥é‡ç‚¹ï¼šTF-IDF è®¡ç®—
                // -----------------------------------------
                
                // 1. æŸ¥æ‰¾åŒ…å«è¯¥è¯çš„æ–‡æ¡£åˆ—è¡¨
                // ç®€å•æ¨¡ç³Šç­–ç•¥ï¼šå¦‚æœæˆ‘ä»¬æ‰¾ä¸åˆ°ç²¾ç¡®çš„è¯ï¼Œå°è¯•æŸ¥æ‰¾ç´¢å¼•ä¸­åŒ…å«è¯¥è¯çš„é¡¹
                // (ä¸ºäº†æ€§èƒ½ï¼Œè¿™é‡Œæˆ‘ä»¬ä¸»è¦æ¼”ç¤ºç²¾ç¡®åŒ¹é…çš„ TF-IDFï¼Œæ¨¡ç³ŠåŒ¹é…é€»è¾‘åŒå‰)
                
                // éå†ç´¢å¼•ä¸­çš„æ‰€æœ‰è¯ (å®é™…ç”Ÿäº§ä¸­è¿™æ­¥å¤ªæ…¢ï¼Œé€šå¸¸ç”¨ Trie æ ‘æˆ– FST ä¼˜åŒ–ï¼Œè¿™é‡Œä¸ºäº†æ¼”ç¤ºé€»è¾‘ç®€åŒ–)
                for (const [idxToken, docMap] of this.index) {
                    let matchWeight = 0;

                    if (idxToken === qToken) matchWeight = 1.0; // ç²¾ç¡®åŒ¹é…
                    else if (idxToken.includes(qToken)) matchWeight = 0.3; // æ¨¡ç³ŠåŒ¹é…æƒé‡é™ä½

                    if (matchWeight > 0) {
                        // =======================================
                        // æ ¸å¿ƒå…¬å¼ï¼šIDF è®¡ç®—
                        // IDF = log(N / df)
                        // N = this.docCount (æ€»æ–‡æ¡£æ•°)
                        // df = docMap.size (åŒ…å«è¯¥è¯çš„æ–‡æ¡£æ•°)
                        // =======================================
                        const df = docMap.size;
                        const idf = Math.log10(this.docCount / (df + 1)) + 1; // +1 é˜²æ­¢åˆ†æ¯ä¸º0

                        docMap.forEach((tf, docId) => {
                            // ===================================
                            // æ ¸å¿ƒå…¬å¼ï¼šTF * IDF
                            // ===================================
                            // å¯ä»¥åœ¨è¿™é‡ŒåŠ å…¥ Log å½’ä¸€åŒ– TF: (1 + log(tf))
                            const tfScore = tf; 
                            const score = tfScore * idf * matchWeight;

                            const currentScore = docScores.get(docId) || 0;
                            docScores.set(docId, currentScore + score);
                        });
                    }
                }
            });

            // ç»„è£…ç»“æœ
            const results = [];
            docScores.forEach((score, id) => {
                results.push({
                    ...this.documents.get(id),
                    score: score.toFixed(4) // ä¿ç•™4ä½å°æ•°æ–¹ä¾¿è§‚å¯Ÿ
                });
            });

            return results.sort((a, b) => b.score - a.score);
        }
    }

    // æ›¿æ¢åŸæ¥çš„åˆå§‹åŒ–
    const engine = new AdvancedSearchEngine()

        // ============================================================
        // åº”ç”¨é€»è¾‘ (UI äº¤äº’)
        // ============================================================
      
        const folderInput = document.getElementById('folderInput');
        const searchInput = document.getElementById('searchInput');
        const resultsDiv = document.getElementById('results');
        const loadingMsg = document.getElementById('loadingMsg');
        const statsMsg = document.getElementById('statsMsg');

        // å¤„ç†æ–‡ä»¶å¯¼å…¥
        folderInput.addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            // UI çŠ¶æ€æ›´æ–°
            loadingMsg.style.display = 'block';
            searchInput.disabled = true;
            statsMsg.innerText = `æ­£åœ¨åˆ†æ ${files.length} ä¸ªæ–‡ä»¶...`;

            let processedCount = 0;
            const startTime = performance.now();

            // å¼‚æ­¥è¯»å–æ–‡ä»¶å†…å®¹
            for (const file of files) {
                // ç®€å•çš„è¿‡æ»¤ï¼šåªè¯»æ–‡æœ¬ç±»æ–‡ä»¶ï¼Œé˜²æ­¢è¯»å–å›¾ç‰‡/exeä¹±ç 
                if (file.size < 1000000 && isTextFile(file.name)) { 
                    try {
                        const text = await readFileAsText(file);
                        engine.addDocument(file, text);
                    } catch (err) {
                        console.warn(`æ— æ³•è¯»å–æ–‡ä»¶ ${file.name}:`, err);
                    }
                }
                processedCount++;
            }

            const endTime = performance.now();
            const duration = (endTime - startTime).toFixed(2);

            // å®Œæˆ
            loadingMsg.style.display = 'none';
            searchInput.disabled = false;
            searchInput.placeholder = `åœ¨ ${engine.docCount} ä¸ªæ–‡æ¡£ä¸­æœç´¢...`;
            statsMsg.innerText = `ç´¢å¼•å»ºç«‹å®Œæˆï¼è€—æ—¶ ${duration}msï¼Œæœ‰æ•ˆæ–‡æ¡£ ${engine.docCount} ä¸ªã€‚`;
        });

        // æœç´¢è¾“å…¥ç›‘å¬
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value;
            const results = engine.search(query);
            renderResults(results, query);
        });

        // è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­æ˜¯å¦ä¸ºæ–‡æœ¬æ–‡ä»¶
        function isTextFile(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const textExts = ['txt', 'md', 'js', 'html', 'css', 'json', 'py', 'java', 'c', 'cpp', 'log', 'csv'];
            return textExts.includes(ext);
        }

        // è¾…åŠ©å‡½æ•°ï¼šPromise å°è£… FileReader
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(e);
                reader.readAsText(file);
            });
        }

        // è¾…åŠ©å‡½æ•°ï¼šæå–æ‘˜è¦ (Snippet)
        function getSnippet(text, query) {
            if (!query) return text.substring(0, 100) + '...';
            // æ‰¾åˆ°ç¬¬ä¸€ä¸ªåŒ¹é…è¯çš„ä½ç½®
            const matchIndex = text.toLowerCase().indexOf(query.toLowerCase().split(' ')[0]);
            if (matchIndex === -1) return text.substring(0, 100) + '...';
            
            const start = Math.max(0, matchIndex - 30);
            const end = Math.min(text.length, matchIndex + 100);
            return '...' + text.substring(start, end) + '...';
        }

        // è¾…åŠ©å‡½æ•°ï¼šé«˜äº®æ–‡æœ¬
        function highlight(text, query) {
            if (!query) return text;
            const terms = query.toLowerCase().split(/\s+/).filter(t=>t);
            let html = text;
            terms.forEach(term => {
                // ç®€å•çš„æ­£åˆ™æ›¿æ¢ (æ³¨æ„ï¼šè¿™é‡Œä¸ºäº†æ¼”ç¤ºç®€åŒ–äº†æ­£åˆ™ç‰¹æ®Šå­—ç¬¦å¤„ç†)
                const regex = new RegExp(`(${term})`, 'gi');
                html = html.replace(regex, '<span class="highlight">$1</span>');
            });
            return html;
        }

        // æ¸²æŸ“ç»“æœ
        function renderResults(results, query) {
            if (!query) { resultsDiv.innerHTML = ''; return; }
            if (results.length === 0) {
                resultsDiv.innerHTML = '<div style="text-align:center; color:#a0aec0; padding:20px;">æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„æ–‡æ¡£</div>';
                return;
            }

            resultsDiv.innerHTML = results.map(doc => {
                // ç”Ÿæˆ Blob URL ç”¨äºæ‰“å¼€æ–‡ä»¶
                const blobUrl = URL.createObjectURL(doc.fileRef);
                
                return `
                    <div class="result-item" onclick="window.open('${blobUrl}', '_blank')">
                        <div class="result-title">
                            ${highlight(doc.name, query)}
                            <span class="score-badge">Score: ${doc.score}</span>
                        </div>
                        <div class="result-path">${doc.path}</div>
                        <div class="result-snippet">${highlight(getSnippet(doc.content, query), query)}</div>
                    </div>
                `;
            }).join('');
        }
    </script>
</body>
</html>